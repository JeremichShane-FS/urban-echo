name: "Auto Issue Creation"
on:
  push:
    branches: [main, staging, dev]
  workflow_dispatch:

jobs:
  todo-to-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: "TODO to Issue"
        uses: alstr/todo-to-issue-action@v5
        with:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          CLOSE_ISSUES: "true"
          AUTO_P: "false"
          # Create with no labels - labels added in next job
          # Only process valid TODO/FIX comments with proper templates
          IDENTIFIERS: >
            [
              {"name": "TODO:", "labels": []},
              {"name": "FIX:", "labels": []}
            ]
          ISSUE_TEMPLATE: "{{ body }}\n\n---\n**File:** [{{ url }}]({{ url }})\n\n**Code Context:**\n```javascript\n{{ snippet }}\n```"

  apply-labels:
    needs: todo-to-issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: "Apply Labels to TODO Issues"
        run: |
          echo "üè∑Ô∏è Applying labels to recent TODO/FIX issues..."

          # Wait for TODO issues to be fully created
          sleep 30

          # Only process issues created in the last 5 minutes
          CUTOFF_TIME=$(date -d '5 minutes ago' --iso-8601=seconds)
          echo "üîç Looking for TODO/FIX issues created after: $CUTOFF_TIME"

          gh issue list --limit 20 --json number,title,body,createdAt | jq -r --arg cutoff "$CUTOFF_TIME" '.[] | select(.createdAt > $cutoff) | "\(.number)|\(.title)"' | while IFS='|' read -r number title; do
            if [[ -n "$number" && -n "$title" ]]; then
              echo ""
              echo "üìù Processing issue #$number: $title"
              
              # Process ALL recent issues - don't filter by title since action strips TODO:/FIX:
              echo "   ‚úÖ Recent issue detected - checking for TODO/FIX origin..."
              
              # Get the commit author for assignment
              COMMIT_AUTHOR="${{ github.actor }}"
              echo "   üë§ Assigning to commit author: $COMMIT_AUTHOR"
              
              # Get the full issue body for content analysis
              ISSUE_BODY=$(gh issue view "$number" --json body --jq '.body' 2>/dev/null || echo "")
              CONTENT="$title $ISSUE_BODY"
              
              # Check if this issue was created from TODO/FIX comment by looking for file path in body
              if [[ "$ISSUE_BODY" =~ \*\*File:\*\* ]] || [[ "$ISSUE_BODY" =~ \*\*Code:\*\* ]]; then
                echo "   ‚úÖ Confirmed TODO/FIX issue - validating and applying labels"
                
                # VALIDATION: Check for required template format
                if [[ ! "$title" =~ ^\[.*\] ]]; then
                  echo "   ‚ùå ERROR: TODO/FIX comment must have template prefix [TEMPLATE]"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  gh issue comment "$number" --body "üö´ **Validation Failed**: TODO/FIX comments must include a template prefix like [COMPONENT], [SECURITY], [DOCS], etc." 2>/dev/null || true
                  continue
                fi
                
                # VALIDATION: Check for empty content (check content after template, not total length)
                CONTENT_AFTER_TEMPLATE=$(echo "$title" | sed 's/^\[[^]]*\][[:space:]]*//')
                if [[ ${#CONTENT_AFTER_TEMPLATE} -lt 10 ]]; then
                  echo "   ‚ùå ERROR: TODO/FIX content after template too short (minimum 10 characters, got ${#CONTENT_AFTER_TEMPLATE})"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  gh issue comment "$number" --body "üö´ **Validation Failed**: TODO/FIX content after template must be at least 10 characters long. Currently: '${CONTENT_AFTER_TEMPLATE}' (${#CONTENT_AFTER_TEMPLATE} characters)." 2>/dev/null || true
                  continue
                fi
                
                # VALIDATION: Check for multiple templates
                TEMPLATE_COUNT=$(echo "$title" | grep -o '\[.*\]' | wc -l)
                if [[ $TEMPLATE_COUNT -gt 1 ]]; then
                  echo "   ‚ùå ERROR: Multiple templates detected - only one template allowed"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  gh issue comment "$number" --body "üö´ **Validation Failed**: Only one template prefix allowed per TODO/FIX comment. Use either [COMPONENT] OR [SECURITY], not both." 2>/dev/null || true
                  continue
                fi
                
                # VALIDATION: Check for valid template
                TEMPLATE=$(echo "$title" | grep -o '\[[^]]*\]' | tr '[:lower:]' '[:upper:]')
                VALID_TEMPLATES=("COMPONENT" "UI/UX" "ROUTES" "DATA" "SECURITY" "BUG" "PERF" "REFACTOR" "TEST" "DOCS" "DEPENDENCY" "ONBOARDING" "I18N" "A11Y" "FEATURE" "RESEARCH" "STATE")
                TEMPLATE_NAME=$(echo "$TEMPLATE" | sed 's/\[//g' | sed 's/\]//g')
                
                VALID_TEMPLATE=false
                for valid in "${VALID_TEMPLATES[@]}"; do
                  if [[ "$TEMPLATE_NAME" == "$valid" ]]; then
                    VALID_TEMPLATE=true
                    break
                  fi
                done
                
                if [[ "$VALID_TEMPLATE" == "false" ]]; then
                  echo "   ‚ùå ERROR: Invalid template [$TEMPLATE_NAME] - not in approved list"
                  echo "   üè∑Ô∏è Adding validation-failed label and comment"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  gh issue comment "$number" --body "üö´ **Validation Failed**: Template [$TEMPLATE_NAME] is not valid. Use one of: [COMPONENT], [SECURITY], [DOCS], [BUG], [PERF], [REFACTOR], [TEST], [ROUTES], [DATA], [UI/UX], [DEPENDENCY], [ONBOARDING], [I18N], [A11Y], [FEATURE], [RESEARCH], [STATE]." 2>/dev/null || true
                  echo "   ‚úÖ Validation-failed label applied"
                  continue
                fi
                
                # VALIDATION: Check for non-English characters
                if echo "$title" | grep -q '[^[:print:][:space:]]' || echo "$title" | grep -qP '[^\x00-\x7F]'; then
                  echo "   ‚ùå ERROR: Non-English characters detected in title"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  gh issue comment "$number" --body "üö´ **Validation Failed**: TODO/FIX comments must use English characters only." 2>/dev/null || true
                  continue
                fi
                
                # VALIDATION: Check for special characters that might break CLI
                if [[ "$title" =~ [\$\`\&\|\>\<\;\(\)\{\}] ]]; then
                  echo "   ‚ùå ERROR: Special characters detected that may cause issues"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  gh issue comment "$number" --body "üö´ **Validation Failed**: TODO/FIX comments cannot contain special characters: \$ \` & | > < ; ( ) { }" 2>/dev/null || true
                  continue
                fi
                
                # Truncate title if too long (GitHub limit ~80 chars for single line display)
                if [[ ${#title} -gt 80 ]]; then
                  ORIGINAL_TITLE="$title"
                  title="${title:0:77}..."
                  echo "   ‚úÇÔ∏è Title truncated from ${#ORIGINAL_TITLE} to ${#title} characters"
                  gh issue edit "$number" --title "$title" 2>/dev/null || true
                fi
                
                # Normalize template to uppercase
                if [[ "$title" =~ ^\[.*\] ]]; then
                  PREFIX_PART=$(echo "$title" | grep -o '^\[[^]]*\]' | tr '[:lower:]' '[:upper:]')
                  REST_OF_TITLE=$(echo "$title" | sed 's/^\[[^]]*\]//')
                  NORMALIZED_TITLE="$PREFIX_PART$REST_OF_TITLE"
                  if [[ "$NORMALIZED_TITLE" != "$title" ]]; then
                    echo "   üìù Normalizing template to uppercase: $PREFIX_PART"
                    gh issue edit "$number" --title "$NORMALIZED_TITLE" 2>/dev/null || true
                    title="$NORMALIZED_TITLE"
                  fi
                fi
                
                echo "   üè∑Ô∏è Adding base labels..."
                # Always add these labels first
                gh issue edit "$number" --add-label "auto-generated" 2>/dev/null || true
                gh issue edit "$number" --add-label "type: enhancement" 2>/dev/null || true
                
                # Check if this was a FIX comment without template - this should not happen after validation
                if [[ ! "$title" =~ \[.*\] ]] && [[ "$ISSUE_BODY" =~ FIX: ]]; then
                  echo "   ‚ùå ERROR: FIX comment without template should have been caught in validation"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  continue
                fi
                
                # Assign the issue to the person who pushed the code
                gh issue edit "$number" --add-assignee "$COMMIT_AUTHOR" 2>/dev/null || true
                
                # Template-based labeling (templates are now guaranteed to be valid and uppercase)
                if [[ "$title" =~ \[COMPONENT\]|\[UI/UX\] ]]; then
                  echo "     üé® Frontend template detected: $title"
                  gh issue edit "$number" --add-label "area: frontend" 2>/dev/null || true
                  gh issue edit "$number" --add-label "priority: medium" 2>/dev/null || true
                elif [[ "$title" =~ \[ROUTES\]|\[DATA\] ]]; then
                  echo "     üîå API/Backend template detected: $title"
                  gh issue edit "$number" --add-label "area: api" 2>/dev/null || true
                  gh issue edit "$number" --add-label "area: backend" 2>/dev/null || true
                  gh issue edit "$number" --add-label "priority: medium" 2>/dev/null || true
                elif [[ "$title" =~ \[SECURITY\] ]]; then
                  echo "     üîí Security template detected: $title"
                  gh issue edit "$number" --add-label "area: security" 2>/dev/null || true
                  gh issue edit "$number" --add-label "priority: high" 2>/dev/null || true
                  # If this was a FIX comment, change to type: bug (security vulnerability)
                  if [[ "$ISSUE_BODY" =~ FIX: ]]; then
                    echo "     üêõ Security FIX detected - changing to type: bug"
                    gh issue edit "$number" --remove-label "type: enhancement" 2>/dev/null || true
                    gh issue edit "$number" --add-label "type: bug" 2>/dev/null || true
                  fi
                elif [[ "$title" =~ \[BUG\] ]]; then
                  echo "     üêõ Bug template detected: $title"
                  gh issue edit "$number" --remove-label "type: enhancement" 2>/dev/null || true
                  gh issue edit "$number" --add-label "type: bug" 2>/dev/null || true
                  # Higher priority for FIX bugs (actual issues) vs TODO bugs (planned fixes)
                  if [[ "$ISSUE_BODY" =~ FIX: ]]; then
                    echo "     üö® Bug FIX detected - critical priority"
                    gh issue edit "$number" --add-label "priority: high" 2>/dev/null || true
                  else
                    echo "     üìã Bug TODO detected - medium priority"
                    gh issue edit "$number" --add-label "priority: medium" 2>/dev/null || true
                  fi
                elif [[ "$title" =~ \[PERF\] ]]; then
                  echo "     ‚ö° Performance template detected: $title"
                  gh issue edit "$number" --add-label "performance" 2>/dev/null || true
                  gh issue edit "$number" --add-label "priority: medium" 2>/dev/null || true
                elif [[ "$title" =~ \[REFACTOR\] ]]; then
                  echo "     üîß Refactor template detected: $title"
                  gh issue edit "$number" --add-label "tech-debt" 2>/dev/null || true
                  gh issue edit "$number" --add-label "priority: medium" 2>/dev/null || true
                elif [[ "$title" =~ \[TEST\] ]]; then
                  echo "     üß™ Test template detected: $title"
                  gh issue edit "$number" --add-label "priority: medium" 2>/dev/null || true
                elif [[ "$title" =~ \[DOCS\] ]]; then
                  echo "     üìö Documentation template detected: $title"
                  gh issue edit "$number" --remove-label "type: enhancement" 2>/dev/null || true
                  gh issue edit "$number" --add-label "type: documentation" 2>/dev/null || true
                  gh issue edit "$number" --add-label "priority: low" 2>/dev/null || true
                elif [[ "$title" =~ \[DEPENDENCY\] ]]; then
                  echo "     üì¶ Dependency template detected: $title"
                  gh issue edit "$number" --add-label "priority: low" 2>/dev/null || true
                else
                  echo "   ‚ùå ERROR: No template detected - this should have been caught in validation"
                  gh issue edit "$number" --add-label "validation-failed" 2>/dev/null || true
                  continue
                fi
                
                # Add TECHNOLOGY labels only if specifically mentioned
                if [[ "$CONTENT" =~ (Next\.js|NextJS|Next) ]]; then
                  gh issue edit "$number" --add-label "nextjs" 2>/dev/null || true
                fi
                
                # Add WORKFLOW labels only if specifically mentioned in TODO comment text (not code snippet)
                TODO_COMMENT_TEXT="$title"
                if [[ "$ISSUE_BODY" =~ \*\*Code:\*\* ]]; then
                  # Extract just the TODO comment lines from the code block
                  TODO_LINES=$(echo "$ISSUE_BODY" | sed -n '/```javascript/,/```/p' | grep -E '^[[:space:]]*//[[:space:]]*(TODO|FIX)')
                  TODO_COMMENT_TEXT="$title $TODO_LINES"
                fi
                
                if [[ "$TODO_COMMENT_TEXT" =~ (performance.*optimize|optimize.*speed) ]]; then
                  echo "     ‚ö° Adding performance label"
                  gh issue edit "$number" --add-label "performance" 2>/dev/null || true
                fi
                
                if [[ "$TODO_COMMENT_TEXT" =~ (refactor.*code|technical.*debt) ]]; then
                  echo "     üîß Adding tech-debt label"
                  gh issue edit "$number" --add-label "tech-debt" 2>/dev/null || true
                fi
                
                if [[ "$TODO_COMMENT_TEXT" =~ (console\.|console |alert\(|debugger) ]]; then
                  echo "     üßπ Adding cleanup label"
                  gh issue edit "$number" --add-label "cleanup" 2>/dev/null || true
                fi
                
                echo "   ‚úÖ Labels applied to TODO/FIX issue #$number"
                echo "   üë§ Assigned to: $COMMIT_AUTHOR"
                
                # Show final labels
                FINAL_LABELS=$(gh issue view "$number" --json labels --jq '.labels | map(.name) | join(", ")' 2>/dev/null || echo "Failed to get labels")
                echo "   üè∑Ô∏è Final labels: $FINAL_LABELS"
              else
                echo "   ‚ö†Ô∏è Not a TODO/FIX issue (no file/code markers) - skipping"
              fi
            fi
          done

          echo ""
          echo "üéâ TODO/FIX labeling complete!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
