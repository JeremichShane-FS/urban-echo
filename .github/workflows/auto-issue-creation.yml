name: "Auto Issue Creation"
on:
  push:
    branches: [main, staging, dev]
  workflow_dispatch:

jobs:
  todo-to-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: "Debug TODO Comments in Repository"
        run: |
          echo "üîç Searching for TODO: comments in repository..."
          find . -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" | \
            xargs grep -n "TODO:" | head -10 || echo "No TODO: comments found"

          echo ""
          echo "üìä TODO: comment count:"
          find . -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" | \
            xargs grep -c "TODO:" 2>/dev/null | awk -F: '{sum += $2} END {print sum}' || echo "0"

      - name: "TODO to Issue"
        uses: alstr/todo-to-issue-action@v5
        with:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          CLOSE_ISSUES: "true"
          AUTO_P: "false"
          # No labels from the action - we'll add proper ones later
          IDENTIFIERS: >
            [
              {"name": "TODO:", "labels": []}
            ]
          ISSUE_TEMPLATE: |
            {{ body }}

            ---
            **File:** {{ url }}

            ```
            {{ snippet }}
            ```

  apply-professional-labels:
    needs: todo-to-issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - name: "Apply Professional Labels from Automation Guide"
        run: |
          echo "üè∑Ô∏è Applying professional labels from automation guide..."

          # Get recent issues (last 10 minutes)
          echo "üîç Finding recent issues to label..."
          gh issue list --limit 20 --json number,title,body,createdAt | jq -r '.[] | "\(.number)|\(.title)|\(.body)"' | while IFS='|' read -r number title body; do
            if [[ -n "$number" ]]; then
              echo ""
              echo "üìù Processing issue #$number: $title"
              
              # Always add these base labels to every auto-generated issue
              echo "  üè∑Ô∏è Adding base auto-generated labels"
              gh issue edit "$number" --add-label "auto-generated"
              
              # Determine TYPE based on your automation guide keywords
              echo "  üîç Determining issue type..."
              if [[ "$title" =~ (TODO|Define|Develop|Implement|Create) ]]; then
                echo "  ‚úÖ Adding type: enhancement"
                gh issue edit "$number" --add-label "type: enhancement"
              fi
              
              # Determine AREA based on content (from your automation guide)
              echo "  üîç Analyzing content for area labels..."
              CONTENT="$title $body"
              
              # Area: API (API, endpoint, route, backend)
              if [[ "$CONTENT" =~ (API|endpoint|route|backend|integration) ]]; then
                echo "  üîå Adding area: api"
                gh issue edit "$number" --add-label "area: api"
              fi
              
              # Area: Frontend (UI, component, frontend, hero, CMS)
              if [[ "$CONTENT" =~ (Component|hero|Dynamic|CMS|frontend|UI|design) ]]; then
                echo "  üé® Adding area: frontend"
                gh issue edit "$number" --add-label "area: frontend"
              fi
              
              # Area: Database (database, DB, mongo, schema, model)
              if [[ "$CONTENT" =~ (database|DB|mongo|schema|model|data) ]]; then
                echo "  üóÑÔ∏è Adding area: database + mongodb"
                gh issue edit "$number" --add-label "area: database,mongodb"
              fi
              
              # Area: Payment (payment, stripe, checkout, billing)
              if [[ "$CONTENT" =~ (payment|stripe|checkout|billing|transaction) ]]; then
                echo "  üí≥ Adding area: payment + stripe"
                gh issue edit "$number" --add-label "area: payment,stripe"
              fi
              
              # Area: Security (security, auth, login, token, password)
              if [[ "$CONTENT" =~ (security|auth|login|token|password|authentication) ]]; then
                echo "  üîí Adding area: security"
                gh issue edit "$number" --add-label "area: security"
              fi
              
              # Technology Labels (from your guide)
              if [[ "$CONTENT" =~ (mongo|MongoDB) ]]; then
                echo "  üóÉÔ∏è Adding mongodb label"
                gh issue edit "$number" --add-label "mongodb"
              fi
              
              if [[ "$CONTENT" =~ (stripe|Stripe) ]]; then
                echo "  üí≥ Adding stripe label"
                gh issue edit "$number" --add-label "stripe"
              fi
              
              if [[ "$CONTENT" =~ (auth0|Auth0|authentication) ]]; then
                echo "  üîê Adding auth0 label"
                gh issue edit "$number" --add-label "auth0"
              fi
              
              if [[ "$CONTENT" =~ (next|Next\.js|nextjs) ]]; then
                echo "  ‚ö° Adding nextjs label"
                gh issue edit "$number" --add-label "nextjs"
              fi
              
              # Priority Labels (from your automation guide)
              echo "  üîç Determining priority..."
              if [[ "$CONTENT" =~ (critical|urgent|security|payment|breaking) ]]; then
                echo "  üö® Adding priority: high"
                gh issue edit "$number" --add-label "priority: high"
              elif [[ "$CONTENT" =~ (API|integration|CMS|Version|important|should) ]]; then
                echo "  üìã Adding priority: medium"
                gh issue edit "$number" --add-label "priority: medium"
              else
                echo "  üìù Adding priority: low"
                gh issue edit "$number" --add-label "priority: low"
              fi
              
              # Workflow Labels (from your guide)
              if [[ "$CONTENT" =~ (performance|optimize|slow|speed|bottleneck) ]]; then
                echo "  üöÄ Adding performance label"
                gh issue edit "$number" --add-label "performance"
              fi
              
              if [[ "$CONTENT" =~ (refactor|debt|hack|cleanup) ]]; then
                echo "  üîß Adding tech-debt label"
                gh issue edit "$number" --add-label "tech-debt"
              fi
              
              echo "  ‚úÖ Professional labels applied to issue #$number"
              
              # Show final result
              FINAL_LABELS=$(gh issue view "$number" --json labels --jq '.labels | map(.name) | join(", ")')
              echo "  üè∑Ô∏è Final labels: $FINAL_LABELS"
            fi
          done

          echo ""
          echo "üéâ Professional labeling complete!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  conventional-commit-analysis:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "Analyze Conventional Commits"
        run: |
          # Get full commit message
          FULL_COMMIT_MSG=$(git log -1 --pretty=%B)
          COMMIT_HASH=$(git log -1 --pretty=%H)
          AUTHOR=$(git log -1 --pretty=%an)

          echo "Analyzing conventional commit: $FULL_COMMIT_MSG"

          # Skip merge commits
          if echo "$FULL_COMMIT_MSG" | grep -q "^Merge"; then
            echo "Skipping merge commit"
            exit 0
          fi

          # Check if this commit already has an issue created
          EXISTING_ISSUE=$(gh issue list --label "auto-generated" --search "$COMMIT_HASH" --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ ! -z "$EXISTING_ISSUE" ]; then
            echo "Issue already exists for commit $COMMIT_HASH (Issue #$EXISTING_ISSUE)"
            exit 0
          fi

          # Parse conventional commit format: type(scope): subject
          COMMIT_HEADER=$(echo "$FULL_COMMIT_MSG" | head -n 1)
          COMMIT_BODY=$(echo "$FULL_COMMIT_MSG" | tail -n +3)

          # Extract type and scope using simple string parsing
          COMMIT_TYPE=""
          COMMIT_SCOPE=""
          COMMIT_SUBJECT="$COMMIT_HEADER"

          # Check if it matches conventional commit format
          if [[ "$COMMIT_HEADER" == *":"* ]]; then
            # Extract everything before the colon
            TYPE_PART="${COMMIT_HEADER%%:*}"
            # Extract everything after the colon and space
            COMMIT_SUBJECT="${COMMIT_HEADER#*: }"
            
            # Check if there's a scope in parentheses
            if [[ "$TYPE_PART" == *"("*")" ]]; then
              COMMIT_TYPE="${TYPE_PART%%(*}"
              SCOPE_PART="${TYPE_PART#*(}"
              COMMIT_SCOPE="${SCOPE_PART%)*}"
            else
              COMMIT_TYPE="$TYPE_PART"
            fi
            
            echo "Parsed conventional commit successfully"
          else
            echo "Not a conventional commit format, skipping analysis"
            exit 0
          fi

          echo "Commit Type: $COMMIT_TYPE"
          echo "Commit Scope: $COMMIT_SCOPE"
          echo "Commit Subject: $COMMIT_SUBJECT"

          # Determine priority based on commit type
          case $COMMIT_TYPE in
            "fix"|"hotfix"|"security")
              PRIORITY="priority: high"
              ;;
            "feat"|"perf"|"refactor")
              PRIORITY="priority: medium"
              ;;
            "docs"|"style"|"test"|"chore")
              PRIORITY="priority: low"
              ;;
            *)
              PRIORITY="priority: medium"
              ;;
          esac

          # Create issues based on commit type and content analysis

          # Security-related commits
          if [[ "$COMMIT_TYPE" == "security" ]] || echo "$FULL_COMMIT_MSG" | grep -iE "(security|vulnerability|auth|authentication|password|token|encrypt)"; then
            gh issue create \
              --title "üîí Security Review: $COMMIT_SUBJECT" \
              --body "**Security-Related Commit Detected**

          **Type:** \`$COMMIT_TYPE\`
          **Scope:** \`$COMMIT_SCOPE\`
          **Subject:** $COMMIT_SUBJECT
          **Commit:** $COMMIT_HASH
          **Author:** $AUTHOR
          **Branch:** ${{ github.ref_name }}

          **Full Commit Message:**
          \`\`\`
          $FULL_COMMIT_MSG
          \`\`\`

          **Security Review Checklist:**
          - [ ] Authentication mechanisms reviewed
          - [ ] Data validation implemented
          - [ ] Input sanitization verified
          - [ ] API security confirmed
          - [ ] Payment processing security validated
          - [ ] Access controls verified" \
              --label "area: security,priority: high,auto-generated"
          fi

          # Performance-related commits
          if [[ "$COMMIT_TYPE" == "perf" ]] || echo "$FULL_COMMIT_MSG" | grep -iE "(performance|optimize|slow|speed|bottleneck)"; then
            gh issue create \
              --title "üöÄ Performance Review: $COMMIT_SUBJECT" \
              --body "**Performance-Related Commit Detected**

          **Type:** \`$COMMIT_TYPE\`
          **Scope:** \`$COMMIT_SCOPE\`
          **Subject:** $COMMIT_SUBJECT
          **Commit:** $COMMIT_HASH
          **Author:** $AUTHOR
          **Branch:** ${{ github.ref_name }}

          **Performance Review Checklist:**
          - [ ] Page load times measured
          - [ ] Database query optimization verified
          - [ ] Image optimization confirmed
          - [ ] Bundle size impact assessed
          - [ ] Caching opportunities evaluated
          - [ ] Memory usage analyzed" \
              --label "performance,$PRIORITY,auto-generated"
          fi

          # Database-related commits
          if echo "$COMMIT_SCOPE,$FULL_COMMIT_MSG" | grep -iE "(database|mongo|db|query|schema|migration|model)"; then
            gh issue create \
              --title "üóÑÔ∏è Database Review: $COMMIT_SUBJECT" \
              --body "**Database-Related Commit Detected**

          **Type:** \`$COMMIT_TYPE\`
          **Scope:** \`$COMMIT_SCOPE\`
          **Subject:** $COMMIT_SUBJECT
          **Commit:** $COMMIT_HASH
          **Author:** $AUTHOR
          **Branch:** ${{ github.ref_name }}

          **Database Review Checklist:**
          - [ ] Schema changes validated
          - [ ] Query performance tested
          - [ ] Data migration requirements assessed
          - [ ] Indexing strategy reviewed
          - [ ] Backup considerations evaluated
          - [ ] Data integrity verified" \
              --label "area: database,mongodb,$PRIORITY,auto-generated"
          fi

          # Payment-related commits
          if echo "$COMMIT_SCOPE,$FULL_COMMIT_MSG" | grep -iE "(payment|stripe|checkout|billing|transaction)"; then
            gh issue create \
              --title "üí≥ Payment System Review: $COMMIT_SUBJECT" \
              --body "**Payment-Related Commit Detected**

          **Type:** \`$COMMIT_TYPE\`
          **Scope:** \`$COMMIT_SCOPE\`
          **Subject:** $COMMIT_SUBJECT
          **Commit:** $COMMIT_HASH
          **Author:** $AUTHOR
          **Branch:** ${{ github.ref_name }}

          **Payment System Review Checklist:**
          - [ ] Stripe integration tested
          - [ ] Payment flow verified
          - [ ] Error handling confirmed
          - [ ] Transaction logging validated
          - [ ] Refund processes tested
          - [ ] Security compliance verified" \
              --label "area: payment,stripe,priority: high,auto-generated"
          fi

          # Breaking changes detection
          if echo "$FULL_COMMIT_MSG" | grep -E "BREAKING CHANGE|!:"; then
            gh issue create \
              --title "‚ö†Ô∏è Breaking Change Review: $COMMIT_SUBJECT" \
              --body "**Breaking Change Detected**

          **Type:** \`$COMMIT_TYPE\`
          **Scope:** \`$COMMIT_SCOPE\`
          **Subject:** $COMMIT_SUBJECT
          **Commit:** $COMMIT_HASH
          **Author:** $AUTHOR
          **Branch:** ${{ github.ref_name }}

          **Breaking Change Review Checklist:**
          - [ ] Migration guide created
          - [ ] Documentation updated
          - [ ] Backward compatibility assessed
          - [ ] Deprecation notices added
          - [ ] Version bump planned
          - [ ] Team notified" \
              --label "type: breaking-change,priority: critical,auto-generated"
          fi

          # Feature commits that might need follow-up
          if [[ "$COMMIT_TYPE" == "feat" ]]; then
            # Check if documentation might be needed
            if ! echo "$FULL_COMMIT_MSG" | grep -iE "(docs|documentation|readme)"; then
              gh issue create \
                --title "üìö Documentation Update Needed: $COMMIT_SUBJECT" \
                --body "**New Feature Documentation Required**

          **Type:** \`$COMMIT_TYPE\`
          **Scope:** \`$COMMIT_SCOPE\`
          **Subject:** $COMMIT_SUBJECT
          **Commit:** $COMMIT_HASH
          **Author:** $AUTHOR
          **Branch:** ${{ github.ref_name }}

          **Documentation Checklist:**
          - [ ] API documentation updated
          - [ ] User guide updated
          - [ ] Code examples added
          - [ ] README updated
          - [ ] Changelog updated
          - [ ] Tests documented" \
                --label "type: documentation,$PRIORITY,auto-generated"
            fi
          fi

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  file-analysis:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "Analyze Changed Files for Issues"
        run: |
          # Get changed files in this commit
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD || echo "")
          COMMIT_HASH=$(git log -1 --pretty=%H)
          AUTHOR=$(git log -1 --pretty=%an)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed files detected"
            exit 0
          fi

          echo "Analyzing changed files: $CHANGED_FILES"

          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]]; then
              echo "Scanning file: $file"
              
              # Skip workflow files to avoid recursive issues
              if [[ "$file" == ".github/workflows/"* ]]; then
                echo "Skipping workflow file: $file"
                continue
              fi
              
              # Look for debug code (fixed regex)
              if grep -n -E "(console\\\.log|debugger|alert\\()" "$file" 2>/dev/null; then
                # Check if issue already exists for this file
                EXISTING_DEBUG_ISSUE=$(gh issue list --label "cleanup" --search "Debug Code Found: Remove debug statements in $file" --json number --jq '.[0].number' 2>/dev/null || echo "")
                
                if [ -z "$EXISTING_DEBUG_ISSUE" ]; then
                  gh issue create \
                    --title "üêõ Debug Code Found: Remove debug statements in $file" \
                    --body "**Debug Code Detected**
            
            **File:** $file
            **Commit:** $COMMIT_HASH
            **Author:** $AUTHOR
            
            Debug statements found that should be removed before production:
            
            \`\`\`
            $(grep -n -E "(console\\\.log|debugger|alert\\()" "$file" | head -5)
            \`\`\`
            
            Please remove these debug statements." \
                    --label "type: bug,cleanup,auto-generated"
                fi
              fi
              
              # Look for hardcoded values (fixed regex)
              if grep -n -E "(localhost|127\\\.0\\\.0\\\.1|http://|mongodb://.*password)" "$file" 2>/dev/null; then
                # Check if issue already exists for this file
                EXISTING_HARDCODE_ISSUE=$(gh issue list --label "area: security" --search "Hardcoded Values: Environment variables needed in $file" --json number --jq '.[0].number' 2>/dev/null || echo "")
                
                if [ -z "$EXISTING_HARDCODE_ISSUE" ]; then
                  gh issue create \
                    --title "‚ö†Ô∏è Hardcoded Values: Environment variables needed in $file" \
                    --body "**Hardcoded Values Detected**
            
            **File:** $file
            **Commit:** $COMMIT_HASH
            **Author:** $AUTHOR
            
            Hardcoded values found that should use environment variables:
            
            \`\`\`
            $(grep -n -E "(localhost|127\\\.0\\\.0\\\.1|http://|mongodb://.*password)" "$file" | head -3)
            \`\`\`
            
            Please move these to environment variables for security and flexibility." \
                    --label "area: security,priority: high,auto-generated"
                fi
              fi
              
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
